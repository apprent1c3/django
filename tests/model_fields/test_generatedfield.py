import uuid
from decimal import Decimal

from django.apps import apps
from django.core.exceptions import ValidationError
from django.db import IntegrityError, connection
from django.db.models import (
    CharField,
    F,
    FloatField,
    GeneratedField,
    IntegerField,
    Model,
)
from django.db.models.functions import Lower
from django.test import SimpleTestCase, TestCase, skipUnlessDBFeature
from django.test.utils import isolate_apps

from .models import (
    Foo,
    GeneratedModel,
    GeneratedModelCheckConstraint,
    GeneratedModelCheckConstraintVirtual,
    GeneratedModelFieldWithConverters,
    GeneratedModelNull,
    GeneratedModelNullVirtual,
    GeneratedModelOutputFieldDbCollation,
    GeneratedModelOutputFieldDbCollationVirtual,
    GeneratedModelParams,
    GeneratedModelParamsVirtual,
    GeneratedModelUniqueConstraint,
    GeneratedModelUniqueConstraintVirtual,
    GeneratedModelVirtual,
)


class BaseGeneratedFieldTests(SimpleTestCase):
    def test_editable_unsupported(self):
        """
        Tests that attempting to create a GeneratedField with editable=True raises a ValueError.

        This test ensures that the GeneratedField class correctly enforces the constraint that it cannot be editable, 
        as generated fields are intended to be read-only and computed on the fly, rather than being stored in the database.

        :raises: ValueError with a message indicating that GeneratedField cannot be editable.
        """
        with self.assertRaisesMessage(ValueError, "GeneratedField cannot be editable."):
            GeneratedField(
                expression=Lower("name"),
                output_field=CharField(max_length=255),
                editable=True,
                db_persist=False,
            )

    @isolate_apps("model_fields")
    def test_contribute_to_class(self):
        """

        Tests the contribute_to_class method of the GeneratedField class.

        This test ensures that when a GeneratedField is added to a model class, it is correctly 
        added to the model's _meta fields and becomes accessible by its given name.

        The test creates a simple model class, defines a new GeneratedField instance, and 
        then attempts to add it to the model class. The test verifies that the field is 
        successfully added by checking if it is present in the model's _meta fields.

        The test also covers the scenario where the models are not fully ready, by temporarily 
        setting the apps.models_ready flag to False during the test.

        """
        class BareModel(Model):
            pass

        new_field = GeneratedField(
            expression=Lower("nonexistent"),
            output_field=IntegerField(),
            db_persist=True,
        )
        apps.models_ready = False
        try:
            # GeneratedField can be added to the model even when apps are not
            # fully loaded.
            new_field.contribute_to_class(BareModel, "name")
            self.assertEqual(BareModel._meta.get_field("name"), new_field)
        finally:
            apps.models_ready = True

    def test_blank_unsupported(self):
        with self.assertRaisesMessage(ValueError, "GeneratedField must be blank."):
            GeneratedField(
                expression=Lower("name"),
                output_field=CharField(max_length=255),
                blank=False,
                db_persist=False,
            )

    def test_default_unsupported(self):
        """
        Tests that setting a default value on a GeneratedField raises an error.

        A GeneratedField is a field that is computed from other fields, and as such,
        it cannot have a default value. This test verifies that attempting to create
        a GeneratedField with a default value results in a ValueError with a clear error message.

        The purpose of this test is to ensure that the GeneratedField behaves as expected
        and raises an error when used in an invalid way. This helps prevent unexpected behavior
        in the application and provides a clear indication of the mistake to the developer.
        """
        msg = "GeneratedField cannot have a default."
        with self.assertRaisesMessage(ValueError, msg):
            GeneratedField(
                expression=Lower("name"),
                output_field=CharField(max_length=255),
                default="",
                db_persist=False,
            )

    def test_database_default_unsupported(self):
        """
        #####
        Tests that a ValueError is raised when a GeneratedField is created with a database default.

        The database default is set in the database level, but the GeneratedField is generated by the database based on a given expression. 
        Therefore, providing a database default for a GeneratedField is not supported and results in an error. 
        The error message indicates that the GeneratedField cannot have a database default.
        """
        msg = "GeneratedField cannot have a database default."
        with self.assertRaisesMessage(ValueError, msg):
            GeneratedField(
                expression=Lower("name"),
                output_field=CharField(max_length=255),
                db_default="",
                db_persist=False,
            )

    def test_db_persist_required(self):
        """
        Tests the required parameter db_persist in the GeneratedField class.

        Verifies that the db_persist attribute must be set to either True or False, 
        and that passing an invalid value (including None) raises a ValueError with a 
        clear error message. This ensures that the GeneratedField class enforces a valid 
        database persistence configuration for generated fields.
        """
        msg = "GeneratedField.db_persist must be True or False."
        with self.assertRaisesMessage(ValueError, msg):
            GeneratedField(
                expression=Lower("name"), output_field=CharField(max_length=255)
            )
        with self.assertRaisesMessage(ValueError, msg):
            GeneratedField(
                expression=Lower("name"),
                output_field=CharField(max_length=255),
                db_persist=None,
            )

    def test_deconstruct(self):
        """
        Tests the deconstruction of a GeneratedField instance.

        The deconstruct method is used to break down the field into its constituent parts, 
        which can be used to recreate the field. This test ensures that the deconstructed 
        path, arguments, and keyword arguments are correctly generated and match the 
        expected values.

        Specifically, it verifies that the deconstructed path is 'django.db.models.GeneratedField', 
        the args list is empty, and the kwargs dictionary contains the correct 'db_persist', 
        'expression', and 'output_field' values. The output_field is compared by deconstructing 
        it and comparing it to the deconstructed IntegerField, ensuring they are equivalent.
        """
        field = GeneratedField(
            expression=F("a") + F("b"), output_field=IntegerField(), db_persist=True
        )
        _, path, args, kwargs = field.deconstruct()
        self.assertEqual(path, "django.db.models.GeneratedField")
        self.assertEqual(args, [])
        self.assertEqual(kwargs["db_persist"], True)
        self.assertEqual(kwargs["expression"], F("a") + F("b"))
        self.assertEqual(
            kwargs["output_field"].deconstruct(), IntegerField().deconstruct()
        )

    @isolate_apps("model_fields")
    def test_get_col(self):
        """

        Tests the get_col method of a field in a model to retrieve a column object.

        The get_col method is used to access the column representation of a field in a model.
        It can be used to get the column object for a field with a specified alias.
        This method is particularly useful when working with generated fields, where the
        column object provides information about the field's output type.

        The tests cover two scenarios: one with an IntegerField and another with a FloatField.
        In both cases, the get_col method is called with and without specifying the field,
        and the output field type of the retrieved column object is verified to match the
        expected type.

        """
        class Square(Model):
            side = IntegerField()
            area = GeneratedField(
                expression=F("side") * F("side"),
                output_field=IntegerField(),
                db_persist=True,
            )

        field = Square._meta.get_field("area")

        col = field.get_col("alias")
        self.assertIsInstance(col.output_field, IntegerField)

        col = field.get_col("alias", field)
        self.assertIsInstance(col.output_field, IntegerField)

        class FloatSquare(Model):
            side = IntegerField()
            area = GeneratedField(
                expression=F("side") * F("side"),
                db_persist=True,
                output_field=FloatField(),
            )

        field = FloatSquare._meta.get_field("area")

        col = field.get_col("alias")
        self.assertIsInstance(col.output_field, FloatField)

        col = field.get_col("alias", field)
        self.assertIsInstance(col.output_field, FloatField)

    @isolate_apps("model_fields")
    def test_cached_col(self):
        """

        Tests the behavior of a cached column in a model's generated field.

        This function verifies that a generated field with a cached column behaves as expected.
        It checks that the cached column is retrieved correctly based on different inputs,
        and that its properties are set correctly.

        The function ensures that the cached column is the same when retrieved with the model's
        database table, but different when retrieved with an alias or a different field type.
        It also checks the target and output field of the cached column.

        """
        class Sum(Model):
            a = IntegerField()
            b = IntegerField()
            total = GeneratedField(
                expression=F("a") + F("b"), output_field=IntegerField(), db_persist=True
            )

        field = Sum._meta.get_field("total")
        cached_col = field.cached_col
        self.assertIs(field.get_col(Sum._meta.db_table), cached_col)
        self.assertIs(field.get_col(Sum._meta.db_table, field), cached_col)
        self.assertIsNot(field.get_col("alias"), cached_col)
        self.assertIsNot(field.get_col(Sum._meta.db_table, IntegerField()), cached_col)
        self.assertIs(cached_col.target, field)
        self.assertIsInstance(cached_col.output_field, IntegerField)


class GeneratedFieldTestMixin:
    def _refresh_if_needed(self, m):
        if not connection.features.can_return_columns_from_insert:
            m.refresh_from_db()
        return m

    def test_unsaved_error(self):
        m = self.base_model(a=1, b=2)
        msg = "Cannot read a generated field from an unsaved model."
        with self.assertRaisesMessage(AttributeError, msg):
            m.field

    def test_full_clean(self):
        """
        Tests that a model instance's full clean method is executed properly.

        Verifies that the model's validation and cleaning logic is applied correctly,
        resulting in the expected field values after saving the instance.

        Checks that the 'field' attribute is updated to its expected value of 3,
        indicating that the full clean operation was successful and the model's
        relationships and computations are correctly established.
        """
        m = self.base_model(a=1, b=2)
        # full_clean() ignores GeneratedFields.
        m.full_clean()
        m.save()
        m = self._refresh_if_needed(m)
        self.assertEqual(m.field, 3)

    @skipUnlessDBFeature("supports_table_check_constraints")
    def test_full_clean_with_check_constraint(self):
        """

        Tests the full clean functionality on a model with a check constraint.

        This test ensures that when a model instance is saved, it enforces any check
        constraints defined on the model. If the instance violates a check constraint,
        a ValidationError is raised with a descriptive message.

        Specifically, this test covers two scenarios:

        * When a model instance satisfies the check constraint, it can be saved
          successfully and any dependent fields (e.g. calculated values) are updated
          accordingly.
        * When a model instance violates the check constraint, attempting to save it
          raises a ValidationError with a message that describes the constraint that
          was violated.

        The test assumes the presence of a model with a check constraint defined, where
        the constraint checks that a specific field value is greater than 0.

        """
        model_name = self.check_constraint_model._meta.verbose_name.capitalize()

        m = self.check_constraint_model(a=2)
        m.full_clean()
        m.save()
        m = self._refresh_if_needed(m)
        self.assertEqual(m.a_squared, 4)

        m = self.check_constraint_model(a=-1)
        with self.assertRaises(ValidationError) as cm:
            m.full_clean()
        self.assertEqual(
            cm.exception.message_dict,
            {"__all__": [f"Constraint “{model_name} a > 0” is violated."]},
        )

    @skipUnlessDBFeature("supports_expression_indexes")
    def test_full_clean_with_unique_constraint_expression(self):
        model_name = self.unique_constraint_model._meta.verbose_name.capitalize()

        m = self.unique_constraint_model(a=2)
        m.full_clean()
        m.save()
        m = self._refresh_if_needed(m)
        self.assertEqual(m.a_squared, 4)

        m = self.unique_constraint_model(a=2)
        with self.assertRaises(ValidationError) as cm:
            m.full_clean()
        self.assertEqual(
            cm.exception.message_dict,
            {"__all__": [f"Constraint “{model_name} a” is violated."]},
        )

    def test_create(self):
        m = self.base_model.objects.create(a=1, b=2)
        m = self._refresh_if_needed(m)
        self.assertEqual(m.field, 3)

    def test_non_nullable_create(self):
        """

        Tests creating a non-nullable instance without providing required values.

        Verifies that attempting to create an instance of the base model without
        specifying mandatory fields results in an IntegrityError being raised.

        """
        with self.assertRaises(IntegrityError):
            self.base_model.objects.create()

    def test_save(self):
        # Insert.
        """

        Tests the save functionality of the model.

        Verifies that the model instance's fields are correctly updated and persisted to the database.
        Checks that the model's calculated field is accurately recalculated and saved when the model's attributes are modified.

        Ensures data consistency by refreshing the model instance from the database after saving changes.

        """
        m = self.base_model(a=2, b=4)
        m.save()
        m = self._refresh_if_needed(m)
        self.assertEqual(m.field, 6)
        # Update.
        m.a = 4
        m.save()
        m.refresh_from_db()
        self.assertEqual(m.field, 8)

    def test_save_model_with_pk(self):
        m = self.base_model(pk=1, a=1, b=2)
        m.save()
        m = self._refresh_if_needed(m)
        self.assertEqual(m.field, 3)

    def test_save_model_with_foreign_key(self):
        """

        Tests the saving of a model instance that includes a foreign key.

        Verifies that the model instance can be successfully saved with an associated foreign key object,
        and that the instance's fields are correctly updated after saving.

        Checks the following:
        - A foreign key object is created and associated with the model instance.
        - The model instance is saved to the database.
        - The instance's fields are correctly updated after saving, with a specific field expected to have a value of 3.

        This test ensures that the model's save functionality works correctly with foreign key relationships.

        """
        fk_object = Foo.objects.create(a="abc", d=Decimal("12.34"))
        m = self.base_model(a=1, b=2, fk=fk_object)
        m.save()
        m = self._refresh_if_needed(m)
        self.assertEqual(m.field, 3)

    def test_generated_fields_can_be_deferred(self):
        """

        Tests that generated fields can be deferred when querying the database.

        This test case verifies that when a model instance is retrieved from the database
        with deferred fields, the deferred fields are correctly identified and can be
        retrieved later. The test creates a foreign key object and a model instance,
        then retrieves the instance with a deferred field and checks that the deferred
        field is correctly reported.

        """
        fk_object = Foo.objects.create(a="abc", d=Decimal("12.34"))
        m = self.base_model.objects.create(a=1, b=2, fk=fk_object)
        m = self.base_model.objects.defer("field").get(id=m.id)
        self.assertEqual(m.get_deferred_fields(), {"field"})

    def test_update(self):
        """
        Checks the update functionality of the model by creating an instance, updating its attribute, and verifying the updated value. This test ensures that changes made to the model are correctly persisted and retrieved from the database, with any necessary calculations or updates applied.
        """
        m = self.base_model.objects.create(a=1, b=2)
        self.base_model.objects.update(b=3)
        m = self.base_model.objects.get(pk=m.pk)
        self.assertEqual(m.field, 4)

    def test_bulk_create(self):
        """

        Tests the bulk creation of model instances.

        This test case verifies that a model instance can be successfully created in bulk
        and that the resulting instance has the expected attribute values.
        It covers the scenario where the database backend does or does not support
        returning rows from bulk insert operations.

        The test checks that the 'field' attribute of the created instance has the expected
        value, which is the result of the model's internal calculations based on the
        provided input values 'a' and 'b'.

        """
        m = self.base_model(a=3, b=4)
        (m,) = self.base_model.objects.bulk_create([m])
        if not connection.features.can_return_rows_from_bulk_insert:
            m = self.base_model.objects.get()
        self.assertEqual(m.field, 7)

    def test_bulk_update(self):
        """
        Tests the bulk update functionality of the model.

        This test case creates a model instance, modifies one of its fields, and then uses the 
        bulk update method to persist the changes. It then retrieves the updated model instance 
        and verifies that the field was updated correctly.

        The test covers the scenario where a single field of a model instance is updated and 
        the changes are saved using bulk update, ensuring data consistency and integrity.

        Note: This test assumes that the model instance's 'field' attribute is updated based on 
        the value of 'a' after the bulk update operation, resulting in a final value of 5.
        """
        m = self.base_model.objects.create(a=1, b=2)
        m.a = 3
        self.base_model.objects.bulk_update([m], fields=["a"])
        m = self.base_model.objects.get(pk=m.pk)
        self.assertEqual(m.field, 5)

    def test_output_field_lookups(self):
        """Lookups from the output_field are available on GeneratedFields."""
        internal_type = IntegerField().get_internal_type()
        min_value, max_value = connection.ops.integer_field_range(internal_type)
        if min_value is None:
            self.skipTest("Backend doesn't define an integer min value.")
        if max_value is None:
            self.skipTest("Backend doesn't define an integer max value.")

        does_not_exist = self.base_model.DoesNotExist
        underflow_value = min_value - 1
        with self.assertNumQueries(0), self.assertRaises(does_not_exist):
            self.base_model.objects.get(field=underflow_value)
        with self.assertNumQueries(0), self.assertRaises(does_not_exist):
            self.base_model.objects.get(field__lt=underflow_value)
        with self.assertNumQueries(0), self.assertRaises(does_not_exist):
            self.base_model.objects.get(field__lte=underflow_value)

        overflow_value = max_value + 1
        with self.assertNumQueries(0), self.assertRaises(does_not_exist):
            self.base_model.objects.get(field=overflow_value)
        with self.assertNumQueries(0), self.assertRaises(does_not_exist):
            self.base_model.objects.get(field__gt=overflow_value)
        with self.assertNumQueries(0), self.assertRaises(does_not_exist):
            self.base_model.objects.get(field__gte=overflow_value)

    def test_output_field_db_collation(self):
        collation = connection.features.test_collations["virtual"]
        m = self.output_field_db_collation_model.objects.create(name="NAME")
        field = m._meta.get_field("lower_name")
        db_parameters = field.db_parameters(connection)
        self.assertEqual(db_parameters["collation"], collation)
        self.assertEqual(db_parameters["type"], field.output_field.db_type(connection))

    def test_db_type_parameters(self):
        """
        Tests the database type parameters for the 'lower_name' field.

        Checks that the 'max_length' of the 'lower_name' field in the output field database collation model is correctly set to 11.

        This test ensures that the database collation model is properly configured to handle the 'lower_name' field with the expected maximum length.
        """
        db_type_parameters = self.output_field_db_collation_model._meta.get_field(
            "lower_name"
        ).db_type_parameters(connection)
        self.assertEqual(db_type_parameters["max_length"], 11)

    def test_model_with_params(self):
        m = self.params_model.objects.create()
        m = self._refresh_if_needed(m)
        self.assertEqual(m.field, "Constant")

    def test_nullable(self):
        """

        Tests the functionality of a nullable model field.

        Verifies that the field correctly handles null and non-null values.
        Checks that an instance with a null value is correctly saved and retrieved,
        and that the value is converted to the expected default value.
        Also checks that an instance with a non-null value is correctly saved and retrieved,
        and that the value is converted to the expected formatted value.

        """
        m1 = self.nullable_model.objects.create()
        m1 = self._refresh_if_needed(m1)
        none_val = "" if connection.features.interprets_empty_strings_as_nulls else None
        self.assertEqual(m1.lower_name, none_val)
        m2 = self.nullable_model.objects.create(name="NaMe")
        m2 = self._refresh_if_needed(m2)
        self.assertEqual(m2.lower_name, "name")


@skipUnlessDBFeature("supports_stored_generated_columns")
class StoredGeneratedFieldTests(GeneratedFieldTestMixin, TestCase):
    base_model = GeneratedModel
    nullable_model = GeneratedModelNull
    check_constraint_model = GeneratedModelCheckConstraint
    unique_constraint_model = GeneratedModelUniqueConstraint
    output_field_db_collation_model = GeneratedModelOutputFieldDbCollation
    params_model = GeneratedModelParams

    def test_create_field_with_db_converters(self):
        obj = GeneratedModelFieldWithConverters.objects.create(field=uuid.uuid4())
        obj = self._refresh_if_needed(obj)
        self.assertEqual(obj.field, obj.field_copy)


@skipUnlessDBFeature("supports_virtual_generated_columns")
class VirtualGeneratedFieldTests(GeneratedFieldTestMixin, TestCase):
    base_model = GeneratedModelVirtual
    nullable_model = GeneratedModelNullVirtual
    check_constraint_model = GeneratedModelCheckConstraintVirtual
    unique_constraint_model = GeneratedModelUniqueConstraintVirtual
    output_field_db_collation_model = GeneratedModelOutputFieldDbCollationVirtual
    params_model = GeneratedModelParamsVirtual
