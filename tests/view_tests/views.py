import datetime
import decimal
import logging
import sys
from pathlib import Path

from django.core.exceptions import BadRequest, PermissionDenied, SuspiciousOperation
from django.http import Http404, HttpResponse, JsonResponse
from django.shortcuts import render
from django.template import Context, Template, TemplateDoesNotExist
from django.urls import get_resolver
from django.views import View
from django.views.debug import (
    ExceptionReporter,
    SafeExceptionReporterFilter,
    technical_500_response,
)
from django.views.decorators.debug import sensitive_post_parameters, sensitive_variables

TEMPLATES_PATH = Path(__file__).resolve().parent / "templates"


def index_page(request):
    """Dummy index page"""
    return HttpResponse("<html><body>Dummy page</body></html>")


def with_parameter(request, parameter):
    return HttpResponse("ok")


def raises(request):
    # Make sure that a callable that raises an exception in the stack frame's
    # local vars won't hijack the technical 500 response (#15025).
    """

    Raises an exception and returns a technical 500 response.

    This function simulates an error condition by intentionally raising an exception, 
    then catches the exception and returns a technical 500 response to the client.
    The response is generated based on the provided request and exception information.

    :param request: The incoming request object
    :return: A technical 500 response object

    """
    def callable():
        raise Exception

    try:
        raise Exception
    except Exception:
        return technical_500_response(request, *sys.exc_info())


def raises500(request):
    # We need to inspect the HTML generated by the fancy 500 debug view but
    # the test client ignores it, so we send it explicitly.
    """
    Raises a technical 500 error response for the given HTTP request.

    This function simulates an internal server error by intentionally raising an exception, 
    then catches it and generates a 500 error response using the provided request information. 
    The returned response includes details about the exception that was raised, 
    providing useful diagnostic information for debugging purposes.
    """
    try:
        raise Exception
    except Exception:
        return technical_500_response(request, *sys.exc_info())


class Raises500View(View):
    def get(self, request):
        try:
            raise Exception
        except Exception:
            return technical_500_response(request, *sys.exc_info())


def raises400(request):
    raise SuspiciousOperation


def raises400_bad_request(request):
    raise BadRequest("Malformed request syntax")


def raises403(request):
    raise PermissionDenied("Insufficient Permissions")


def raises404(request):
    """

    Raise a 404 error for testing purposes.

    This function simulates a request to a URL that does not exist in the project's
    URL configuration. It uses the project's URL resolver to attempt to resolve a
    non-existent URL path, resulting in a 404 error being raised.

    Args:
        request: The current request object.

    Returns:
        None

    Raises:
        Http404: When the URL resolution fails.

    """
    resolver = get_resolver(None)
    resolver.resolve("/not-in-urls")


def technical404(request):
    raise Http404("Testing technical 404.")


class Http404View(View):
    def get(self, request):
        raise Http404("Testing class-based technical 404.")


def template_exception(request):
    return render(request, "debug/template_exception.html")


def safestring_in_template_exception(request):
    """
    Trigger an exception in the template machinery which causes a SafeString
    to be inserted as args[0] of the Exception.
    """
    template = Template('{% extends "<script>alert(1);</script>" %}')
    try:
        template.render(Context())
    except Exception:
        return technical_500_response(request, *sys.exc_info())


def jsi18n(request):
    return render(request, "jsi18n.html")


def jsi18n_multi_catalogs(request):
    return render(request, "jsi18n-multi-catalogs.html")


def raises_template_does_not_exist(request, path="i_dont_exist.html"):
    # We need to inspect the HTML generated by the fancy 500 debug view but
    # the test client ignores it, so we send it explicitly.
    """
    Renders the given HTML template, or returns a 500 technical error response if the template does not exist.

    :param request: The HTTP request object
    :param path: The path to the HTML template (default: 'i_dont_exist.html')
    :return: The rendered template response, or a 500 error response if the template is not found

    """
    try:
        return render(request, path)
    except TemplateDoesNotExist:
        return technical_500_response(request, *sys.exc_info())


def render_no_template(request):
    # If we do not specify a template, we need to make sure the debug
    # view doesn't blow up.
    return render(request, [], {})


def send_log(request, exc_info):
    logger = logging.getLogger("django")
    # The default logging config has a logging filter to ensure admin emails are
    # only sent with DEBUG=False, but since someone might choose to remove that
    # filter, we still want to be able to test the behavior of error emails
    # with DEBUG=True. So we need to remove the filter temporarily.
    admin_email_handler = [
        h for h in logger.handlers if h.__class__.__name__ == "AdminEmailHandler"
    ][0]
    orig_filters = admin_email_handler.filters
    admin_email_handler.filters = []
    admin_email_handler.include_html = True
    logger.error(
        "Internal Server Error: %s",
        request.path,
        exc_info=exc_info,
        extra={"status_code": 500, "request": request},
    )
    admin_email_handler.filters = orig_filters


def non_sensitive_view(request):
    # Do not just use plain strings for the variables' values in the code
    # so that the tests don't return false positives when the function's source
    # is displayed in the exception report.
    """

    Handles a non-sensitive view by generating a meaningless response.

    This function intentionally triggers an exception, logs the error, and returns a 500 error response.
    The purpose of this function is to mimic a real-world error scenario, likely for testing or demonstration purposes.

    Parameters
    ----------
    request : object
        The incoming request object.

    Returns
    -------
    A technical 500 error response to the client.

    Notes
    -----
    This function does not perform any meaningful operations and is intended for testing or debugging purposes only.

    """
    cooked_eggs = "".join(["s", "c", "r", "a", "m", "b", "l", "e", "d"])  # NOQA
    sauce = "".join(  # NOQA
        ["w", "o", "r", "c", "e", "s", "t", "e", "r", "s", "h", "i", "r", "e"]
    )
    try:
        raise Exception
    except Exception:
        exc_info = sys.exc_info()
        send_log(request, exc_info)
        return technical_500_response(request, *exc_info)


@sensitive_variables("sauce")
@sensitive_post_parameters("bacon-key", "sausage-key")
def sensitive_view(request):
    # Do not just use plain strings for the variables' values in the code
    # so that the tests don't return false positives when the function's source
    # is displayed in the exception report.
    """

    Handles sensitive data processing and exception handling.

    This view processes sensitive information, including 'bacon-key' and 'sausage-key' 
    post parameters, and handles exceptions that may occur during its execution. 
    If an exception is raised, the view logs the error details and returns a 
    technical 500 response to the client.

    :param request: The incoming HTTP request object.
    :returns: An HTTP response object, either the result of successful processing or 
        a technical 500 response in case of an exception.
    :raises: Exception - Any exception that occurs during the view's execution is 
        caught, logged, and handled by returning a technical 500 response.

    """
    cooked_eggs = "".join(["s", "c", "r", "a", "m", "b", "l", "e", "d"])  # NOQA
    sauce = "".join(  # NOQA
        ["w", "o", "r", "c", "e", "s", "t", "e", "r", "s", "h", "i", "r", "e"]
    )
    try:
        raise Exception
    except Exception:
        exc_info = sys.exc_info()
        send_log(request, exc_info)
        return technical_500_response(request, *exc_info)


@sensitive_variables("sauce")
@sensitive_post_parameters("bacon-key", "sausage-key")
async def async_sensitive_view(request):
    # Do not just use plain strings for the variables' values in the code so
    # that the tests don't return false positives when the function's source is
    # displayed in the exception report.
    """

    Handles an asynchronous request, triggers an exception and logs the event.

    This view function simulates a failure by raising an exception, then captures the 
    exception information and sends it to the logging system along with the request 
    object. It then returns a 500 technical response to the client, providing 
    information about the exception that occurred.

    The function is decorated to mask sensitive variables and post parameters for 
    security reasons, specifically protecting 'sauce' and 'bacon-key' and 'sausage-key' 
    from exposure.

    :param request: The incoming request object
    :return: A technical 500 response with information about the exception

    """
    cooked_eggs = "".join(["s", "c", "r", "a", "m", "b", "l", "e", "d"])  # NOQA
    sauce = "".join(  # NOQA
        ["w", "o", "r", "c", "e", "s", "t", "e", "r", "s", "h", "i", "r", "e"]
    )
    try:
        raise Exception
    except Exception:
        exc_info = sys.exc_info()
        send_log(request, exc_info)
        return technical_500_response(request, *exc_info)


@sensitive_variables("sauce")
@sensitive_post_parameters("bacon-key", "sausage-key")
async def async_sensitive_function(request):
    # Do not just use plain strings for the variables' values in the code so
    # that the tests don't return false positives when the function's source is
    # displayed in the exception report.
    cooked_eggs = "".join(["s", "c", "r", "a", "m", "b", "l", "e", "d"])  # NOQA
    sauce = "".join(  # NOQA
        ["w", "o", "r", "c", "e", "s", "t", "e", "r", "s", "h", "i", "r", "e"]
    )
    raise Exception


async def async_sensitive_view_nested(request):
    try:
        await async_sensitive_function(request)
    except Exception:
        exc_info = sys.exc_info()
        send_log(request, exc_info)
        return technical_500_response(request, *exc_info)


@sensitive_variables()
@sensitive_post_parameters()
def paranoid_view(request):
    # Do not just use plain strings for the variables' values in the code
    # so that the tests don't return false positives when the function's source
    # is displayed in the exception report.
    """

    Handles a view with enhanced security and error handling.

    This view intentionally triggers an exception to test error handling mechanisms. 
    It logs the error using the :func:`send_log` function and returns a technical 500 response 
    using the :func:`technical_500_response` function.

    The function protects sensitive variables and post parameters through the use of 
    @sensitive_variables and @sensitive_post_parameters decorators.

    :returns: A technical 500 response to the client.

    """
    cooked_eggs = "".join(["s", "c", "r", "a", "m", "b", "l", "e", "d"])  # NOQA
    sauce = "".join(  # NOQA
        ["w", "o", "r", "c", "e", "s", "t", "e", "r", "s", "h", "i", "r", "e"]
    )
    try:
        raise Exception
    except Exception:
        exc_info = sys.exc_info()
        send_log(request, exc_info)
        return technical_500_response(request, *exc_info)


def sensitive_args_function_caller(request):
    try:
        sensitive_args_function(
            "".join(
                ["w", "o", "r", "c", "e", "s", "t", "e", "r", "s", "h", "i", "r", "e"]
            )
        )
    except Exception:
        exc_info = sys.exc_info()
        send_log(request, exc_info)
        return technical_500_response(request, *exc_info)


@sensitive_variables("sauce")
def sensitive_args_function(sauce):
    # Do not just use plain strings for the variables' values in the code
    # so that the tests don't return false positives when the function's source
    # is displayed in the exception report.
    """

    Raises an exception after processing the provided sensitive argument.

    This function is designed to handle sensitive information, such as the :param sauce: variable, 
    which is marked as sensitive to maintain security and confidentiality. 
    However, in this case, it simply creates a string representing a dish and then immediately raises an exception.

    :param sauce: The sensitive input to be processed.
    :raises Exception: Always raised, indicating an error or invalid state.

    """
    cooked_eggs = "".join(["s", "c", "r", "a", "m", "b", "l", "e", "d"])  # NOQA
    raise Exception


def sensitive_kwargs_function_caller(request):
    """
    Calls a sensitive keyword arguments function with a hardcoded string, 
    handles exceptions and returns a technical 500 response if an error occurs.

    Args:
        request: The incoming request object

    Returns:
        A technical 500 response if an exception is raised, otherwise None

    Note:
        In case of an exception, the error is logged using the send_log function 
        with the provided request and exception information.
    """
    try:
        sensitive_kwargs_function(
            "".join(
                ["w", "o", "r", "c", "e", "s", "t", "e", "r", "s", "h", "i", "r", "e"]
            )
        )
    except Exception:
        exc_info = sys.exc_info()
        send_log(request, exc_info)
        return technical_500_response(request, *exc_info)


@sensitive_variables("sauce")
def sensitive_kwargs_function(sauce=None):
    # Do not just use plain strings for the variables' values in the code
    # so that the tests don't return false positives when the function's source
    # is displayed in the exception report.
    cooked_eggs = "".join(["s", "c", "r", "a", "m", "b", "l", "e", "d"])  # NOQA
    raise Exception


class UnsafeExceptionReporterFilter(SafeExceptionReporterFilter):
    """
    Ignores all the filtering done by its parent class.
    """

    def get_post_parameters(self, request):
        return request.POST

    def get_traceback_frame_variables(self, request, tb_frame):
        return tb_frame.f_locals.items()


@sensitive_variables()
@sensitive_post_parameters()
def custom_exception_reporter_filter_view(request):
    # Do not just use plain strings for the variables' values in the code
    # so that the tests don't return false positives when the function's source
    # is displayed in the exception report.
    """

    Handles and reports custom exceptions in the application.

    This view function catches and processes exceptions, sending a log notification with relevant error information.
    It utilizes a custom exception reporter filter to handle sensitive data and returns a technical 500 error response.

    The function works by:
        * Setting up an exception reporter filter for the current request
        * Simulating an exception to gather error information
        * Sending a log notification with the error details
        * Returning a technical 500 error response with the exception information

    Note: This function is decorated to protect sensitive variables and post parameters.

    """
    cooked_eggs = "".join(["s", "c", "r", "a", "m", "b", "l", "e", "d"])  # NOQA
    sauce = "".join(  # NOQA
        ["w", "o", "r", "c", "e", "s", "t", "e", "r", "s", "h", "i", "r", "e"]
    )
    request.exception_reporter_filter = UnsafeExceptionReporterFilter()
    try:
        raise Exception
    except Exception:
        exc_info = sys.exc_info()
        send_log(request, exc_info)
        return technical_500_response(request, *exc_info)


class CustomExceptionReporter(ExceptionReporter):
    custom_traceback_text = "custom traceback text"

    def get_traceback_html(self):
        return self.custom_traceback_text


class TemplateOverrideExceptionReporter(ExceptionReporter):
    html_template_path = TEMPLATES_PATH / "my_technical_500.html"
    text_template_path = TEMPLATES_PATH / "my_technical_500.txt"


def custom_reporter_class_view(request):
    """

    View that generates a custom error report.

    This view intentionally raises an exception to trigger the reporting mechanism.
    The exception is caught and handled by returning a technical 500 response,
    utilizing the CustomExceptionReporter class to provide detailed error information.

    Args:
        request: The current HTTP request object.

    Returns:
        A technical 500 response containing error details.

    """
    request.exception_reporter_class = CustomExceptionReporter
    try:
        raise Exception
    except Exception:
        exc_info = sys.exc_info()
        return technical_500_response(request, *exc_info)


class Klass:
    @sensitive_variables("sauce")
    def method(self, request):
        # Do not just use plain strings for the variables' values in the code
        # so that the tests don't return false positives when the function's
        # source is displayed in the exception report.
        """
        Handles an incoming request and returns a technical 500 response in case of an exception.

        This method simulates the preparation of scrambled eggs with Worcestershire sauce by constructing strings representing the dish and its condiment. 

        It intentionally raises an exception to demonstrate error handling. Upon catching the exception, it logs the error information and returns a technical 500 response to the client, ensuring that the exception details are properly handled and communicated.

        :param request: The incoming request object to be processed.
        :returns: A technical 500 response containing exception details, or None if no exception occurs.
        :raises Exception: An intentionally raised exception for demonstration purposes.

        """
        cooked_eggs = "".join(["s", "c", "r", "a", "m", "b", "l", "e", "d"])  # NOQA
        sauce = "".join(  # NOQA
            ["w", "o", "r", "c", "e", "s", "t", "e", "r", "s", "h", "i", "r", "e"]
        )
        try:
            raise Exception
        except Exception:
            exc_info = sys.exc_info()
            send_log(request, exc_info)
            return technical_500_response(request, *exc_info)

    @sensitive_variables("sauce")
    async def async_method(self, request):
        # Do not just use plain strings for the variables' values in the code
        # so that the tests don't return false positives when the function's
        # source is displayed in the exception report.
        """

        Handles an asynchronous request, catching and logging any exceptions that occur.

        This method initiates a process that involves scrambling eggs and creating a sauce, 
        representing a hypothetical cooking operation. If an error occurs during this process, 
        it is caught, logged, and a technical 500 response is returned to the client.

        :param request: The incoming request object
        :return: A technical 500 response if an exception occurs, otherwise undefined

        """
        cooked_eggs = "".join(["s", "c", "r", "a", "m", "b", "l", "e", "d"])  # NOQA
        sauce = "".join(  # NOQA
            ["w", "o", "r", "c", "e", "s", "t", "e", "r", "s", "h", "i", "r", "e"]
        )
        try:
            raise Exception
        except Exception:
            exc_info = sys.exc_info()
            send_log(request, exc_info)
            return technical_500_response(request, *exc_info)

    @sensitive_variables("sauce")
    async def _async_method_inner(self, request):
        # Do not just use plain strings for the variables' values in the code
        # so that the tests don't return false positives when the function's
        # source is displayed in the exception report.
        """

        Inner asynchronous method for handling a request.

        This method performs some preparatory operations by producing two string variables: 
        one representing a food item and the other representing a type of sauce. 
        After these preparations, it raises an exception, potentially for error handling or 
        further processing. The specifics of the exception and the variables are not publicly 
        exposed, as they are marked as sensitive. 

        рут Slov: Parameters
            request: The request to be handled by this method.

        anut Sloan: Raises
            Exception: An exception that is raised after the preparatory operations.

        """
        cooked_eggs = "".join(["s", "c", "r", "a", "m", "b", "l", "e", "d"])  # NOQA
        sauce = "".join(  # NOQA
            ["w", "o", "r", "c", "e", "s", "t", "e", "r", "s", "h", "i", "r", "e"]
        )
        raise Exception

    async def async_method_nested(self, request):
        try:
            await self._async_method_inner(request)
        except Exception:
            exc_info = sys.exc_info()
            send_log(request, exc_info)
            return technical_500_response(request, *exc_info)


def sensitive_method_view(request):
    return Klass().method(request)


async def async_sensitive_method_view(request):
    return await Klass().async_method(request)


async def async_sensitive_method_view_nested(request):
    return await Klass().async_method_nested(request)


@sensitive_variables("sauce")
@sensitive_post_parameters("bacon-key", "sausage-key")
def multivalue_dict_key_error(request):
    """

    Handle KeyError exceptions when accessing multivalue dictionary keys in the request.

    This function attempts to access a specific key in the request's POST data. If the key is not present, it catches the resulting exception, logs the error, and returns a technical 500 response to the client.

    The function takes a single argument, `request`, which is the current HTTP request object. It returns an HTTP response object, specifically a 500 error response, if a KeyError occurs.

    The logging and error handling are performed by the `send_log` and `technical_500_response` functions, which are called with the request object and exception information as arguments.

    Note that this function is decorated to mark certain variables and POST parameters as sensitive, which may affect logging and error reporting behavior.

    """
    cooked_eggs = "".join(["s", "c", "r", "a", "m", "b", "l", "e", "d"])  # NOQA
    sauce = "".join(  # NOQA
        ["w", "o", "r", "c", "e", "s", "t", "e", "r", "s", "h", "i", "r", "e"]
    )
    try:
        request.POST["bar"]
    except Exception:
        exc_info = sys.exc_info()
        send_log(request, exc_info)
        return technical_500_response(request, *exc_info)


def json_response_view(request):
    return JsonResponse(
        {
            "a": [1, 2, 3],
            "foo": {"bar": "baz"},
            # Make sure datetime and Decimal objects would be serialized properly
            "timestamp": datetime.datetime(2013, 5, 19, 20),
            "value": decimal.Decimal("3.14"),
        }
    )
