import copy
import datetime
import os
from unittest import mock

from django.db import DEFAULT_DB_ALIAS, connection, connections
from django.db.backends.base.creation import TEST_DATABASE_PREFIX, BaseDatabaseCreation
from django.test import SimpleTestCase, TransactionTestCase
from django.test.utils import override_settings

from ..models import (
    CircularA,
    CircularB,
    Object,
    ObjectReference,
    ObjectSelfReference,
    SchoolBus,
    SchoolClass,
)


def get_connection_copy():
    # Get a copy of the default connection. (Can't use django.db.connection
    # because it'll modify the default connection itself.)
    test_connection = copy.copy(connections[DEFAULT_DB_ALIAS])
    test_connection.settings_dict = copy.deepcopy(
        connections[DEFAULT_DB_ALIAS].settings_dict
    )
    return test_connection


class TestDbSignatureTests(SimpleTestCase):
    def test_default_name(self):
        # A test db name isn't set.
        prod_name = "hodor"
        test_connection = get_connection_copy()
        test_connection.settings_dict["NAME"] = prod_name
        test_connection.settings_dict["TEST"] = {"NAME": None}
        signature = BaseDatabaseCreation(test_connection).test_db_signature()
        self.assertEqual(signature[3], TEST_DATABASE_PREFIX + prod_name)

    def test_custom_test_name(self):
        # A regular test db name is set.
        """
        Verify that custom test database names are properly applied.

        Tests the behavior of setting custom test database names, ensuring that the
        provided name is correctly reflected in the database creation signature.

        The test checks the database signature of a test database with a custom name,
        confirming that the name is correctly set in the signature. This ensures that
        custom test database names are handled as expected during database creation.

        Args:
            None

        Returns:
            None
        """
        test_name = "hodor"
        test_connection = get_connection_copy()
        test_connection.settings_dict["TEST"] = {"NAME": test_name}
        signature = BaseDatabaseCreation(test_connection).test_db_signature()
        self.assertEqual(signature[3], test_name)

    def test_custom_test_name_with_test_prefix(self):
        # A test db name prefixed with TEST_DATABASE_PREFIX is set.
        """

        Tests that a custom test database name with the test prefix is correctly generated.

        Verifies that the database signature generated by the BaseDatabaseCreation class contains 
        the expected test database name. This ensures that the test database name generated by 
        the TEST_DATABASE_PREFIX followed by the specified name is used correctly.

        """
        test_name = TEST_DATABASE_PREFIX + "hodor"
        test_connection = get_connection_copy()
        test_connection.settings_dict["TEST"] = {"NAME": test_name}
        signature = BaseDatabaseCreation(test_connection).test_db_signature()
        self.assertEqual(signature[3], test_name)


@override_settings(INSTALLED_APPS=["backends.base.app_unmigrated"])
@mock.patch.object(connection, "ensure_connection")
@mock.patch.object(connection, "prepare_database")
@mock.patch(
    "django.db.migrations.recorder.MigrationRecorder.has_table", return_value=False
)
@mock.patch("django.core.management.commands.migrate.Command.sync_apps")
class TestDbCreationTests(SimpleTestCase):
    available_apps = ["backends.base.app_unmigrated"]

    @mock.patch("django.db.migrations.executor.MigrationExecutor.migrate")
    def test_migrate_test_setting_false(
        self, mocked_migrate, mocked_sync_apps, *mocked_objects
    ):
        test_connection = get_connection_copy()
        test_connection.settings_dict["TEST"]["MIGRATE"] = False
        creation = test_connection.creation_class(test_connection)
        if connection.vendor == "oracle":
            # Don't close connection on Oracle.
            creation.connection.close = mock.Mock()
        old_database_name = test_connection.settings_dict["NAME"]
        try:
            with mock.patch.object(creation, "_create_test_db"):
                creation.create_test_db(verbosity=0, autoclobber=True, serialize=False)
            # Migrations don't run.
            mocked_migrate.assert_called()
            args, kwargs = mocked_migrate.call_args
            self.assertEqual(args, ([],))
            self.assertEqual(kwargs["plan"], [])
            # App is synced.
            mocked_sync_apps.assert_called()
            mocked_args, _ = mocked_sync_apps.call_args
            self.assertEqual(mocked_args[1], {"app_unmigrated"})
        finally:
            with mock.patch.object(creation, "_destroy_test_db"):
                creation.destroy_test_db(old_database_name, verbosity=0)

    @mock.patch("django.db.migrations.executor.MigrationRecorder.ensure_schema")
    def test_migrate_test_setting_false_ensure_schema(
        self,
        mocked_ensure_schema,
        mocked_sync_apps,
        *mocked_objects,
    ):
        """

        Tests the migration process when the TEST.MIGRATE setting is set to False.

        This test case verifies that when the TEST.MIGRATE setting is disabled, the 
        MigrationRecorder's ensure_schema method is not called, but the sync_apps method 
        is called with the correct arguments. The test also ensures that the test database 
        is properly created and destroyed.

        The test covers the edge case where the database vendor is Oracle, and verifies 
        that the connection is properly closed in this scenario.

        The test case checks the following conditions:
        - The MigrationRecorder's ensure_schema method is not called.
        - The sync_apps method is called with the correct arguments.
        - The test database is created and destroyed successfully.

        """
        test_connection = get_connection_copy()
        test_connection.settings_dict["TEST"]["MIGRATE"] = False
        creation = test_connection.creation_class(test_connection)
        if connection.vendor == "oracle":
            # Don't close connection on Oracle.
            creation.connection.close = mock.Mock()
        old_database_name = test_connection.settings_dict["NAME"]
        try:
            with mock.patch.object(creation, "_create_test_db"):
                creation.create_test_db(verbosity=0, autoclobber=True, serialize=False)
            # The django_migrations table is not created.
            mocked_ensure_schema.assert_not_called()
            # App is synced.
            mocked_sync_apps.assert_called()
            mocked_args, _ = mocked_sync_apps.call_args
            self.assertEqual(mocked_args[1], {"app_unmigrated"})
        finally:
            with mock.patch.object(creation, "_destroy_test_db"):
                creation.destroy_test_db(old_database_name, verbosity=0)

    @mock.patch("django.db.migrations.executor.MigrationExecutor.migrate")
    def test_migrate_test_setting_true(
        self, mocked_migrate, mocked_sync_apps, *mocked_objects
    ):
        test_connection = get_connection_copy()
        test_connection.settings_dict["TEST"]["MIGRATE"] = True
        creation = test_connection.creation_class(test_connection)
        if connection.vendor == "oracle":
            # Don't close connection on Oracle.
            creation.connection.close = mock.Mock()
        old_database_name = test_connection.settings_dict["NAME"]
        try:
            with mock.patch.object(creation, "_create_test_db"):
                creation.create_test_db(verbosity=0, autoclobber=True, serialize=False)
            # Migrations run.
            mocked_migrate.assert_called()
            args, kwargs = mocked_migrate.call_args
            self.assertEqual(args, ([("app_unmigrated", "0001_initial")],))
            self.assertEqual(len(kwargs["plan"]), 1)
            # App is not synced.
            mocked_sync_apps.assert_not_called()
        finally:
            with mock.patch.object(creation, "_destroy_test_db"):
                creation.destroy_test_db(old_database_name, verbosity=0)

    @mock.patch.dict(os.environ, {"RUNNING_DJANGOS_TEST_SUITE": ""})
    @mock.patch("django.db.migrations.executor.MigrationExecutor.migrate")
    @mock.patch.object(BaseDatabaseCreation, "mark_expected_failures_and_skips")
    def test_mark_expected_failures_and_skips_call(
        self, mark_expected_failures_and_skips, *mocked_objects
    ):
        """
        mark_expected_failures_and_skips() isn't called unless
        RUNNING_DJANGOS_TEST_SUITE is 'true'.
        """
        test_connection = get_connection_copy()
        creation = test_connection.creation_class(test_connection)
        if connection.vendor == "oracle":
            # Don't close connection on Oracle.
            creation.connection.close = mock.Mock()
        old_database_name = test_connection.settings_dict["NAME"]
        try:
            with mock.patch.object(creation, "_create_test_db"):
                creation.create_test_db(verbosity=0, autoclobber=True, serialize=False)
            self.assertIs(mark_expected_failures_and_skips.called, False)
        finally:
            with mock.patch.object(creation, "_destroy_test_db"):
                creation.destroy_test_db(old_database_name, verbosity=0)


class TestDeserializeDbFromString(TransactionTestCase):
    available_apps = ["backends"]

    def test_circular_reference(self):
        # deserialize_db_from_string() handles circular references.
        """

        Tests the handling of circular references in object deserialization.

        Checks that when objects with mutual references are deserialized from a data string, 
        the relationships between these objects are correctly established.

        The test case verifies that the `Object` instance and the `ObjectReference` instance 
        reference each other as expected after deserialization.

        This ensures that the circular reference is correctly resolved, 
        and the objects are properly linked.

        """
        data = """
        [
            {
                "model": "backends.object",
                "pk": 1,
                "fields": {"obj_ref": 1, "related_objects": []}
            },
            {
                "model": "backends.objectreference",
                "pk": 1,
                "fields": {"obj": 1}
            }
        ]
        """
        connection.creation.deserialize_db_from_string(data)
        obj = Object.objects.get()
        obj_ref = ObjectReference.objects.get()
        self.assertEqual(obj.obj_ref, obj_ref)
        self.assertEqual(obj_ref.obj, obj)

    def test_self_reference(self):
        # serialize_db_to_string() and deserialize_db_from_string() handles
        # self references.
        """
        Tests the functionality of self-referential models by creating two objects 
        that reference each other, saving them, and then verifying that the 
        self-referential relationships are correctly preserved after serializing and 
        deserializing the database.

        This test ensures that the self-referential model's integrity is maintained 
        through the serialization and deserialization process, and that the object 
        relationships are correctly re-established after deserialization.
        """
        obj_1 = ObjectSelfReference.objects.create(key="X")
        obj_2 = ObjectSelfReference.objects.create(key="Y", obj=obj_1)
        obj_1.obj = obj_2
        obj_1.save()
        # Serialize objects.
        with mock.patch("django.db.migrations.loader.MigrationLoader") as loader:
            # serialize_db_to_string() serializes only migrated apps, so mark
            # the backends app as migrated.
            loader_instance = loader.return_value
            loader_instance.migrated_apps = {"backends"}
            data = connection.creation.serialize_db_to_string()
        ObjectSelfReference.objects.all().delete()
        # Deserialize objects.
        connection.creation.deserialize_db_from_string(data)
        obj_1 = ObjectSelfReference.objects.get(key="X")
        obj_2 = ObjectSelfReference.objects.get(key="Y")
        self.assertEqual(obj_1.obj, obj_2)
        self.assertEqual(obj_2.obj, obj_1)

    def test_circular_reference_with_natural_key(self):
        # serialize_db_to_string() and deserialize_db_from_string() handles
        # circular references for models with natural keys.
        obj_a = CircularA.objects.create(key="A")
        obj_b = CircularB.objects.create(key="B", obj=obj_a)
        obj_a.obj = obj_b
        obj_a.save()
        # Serialize objects.
        with mock.patch("django.db.migrations.loader.MigrationLoader") as loader:
            # serialize_db_to_string() serializes only migrated apps, so mark
            # the backends app as migrated.
            loader_instance = loader.return_value
            loader_instance.migrated_apps = {"backends"}
            data = connection.creation.serialize_db_to_string()
        CircularA.objects.all().delete()
        CircularB.objects.all().delete()
        # Deserialize objects.
        connection.creation.deserialize_db_from_string(data)
        obj_a = CircularA.objects.get()
        obj_b = CircularB.objects.get()
        self.assertEqual(obj_a.obj, obj_b)
        self.assertEqual(obj_b.obj, obj_a)

    def test_serialize_db_to_string_base_manager(self):
        """

        Tests the serialization of the database to a string using the base database manager.

        This test case ensures that the database contents, including model instances and their attributes, 
        are correctly serialized to a string representation. It specifically checks for the presence of 
        a model instance and one of its attributes in the serialized data.

        The test scenario involves creating a model instance, mocking the migration loader to control the 
        migrated applications, and then verifying that the serialized data contains the expected model 
        and attribute information.

        """
        SchoolClass.objects.create(year=1000, last_updated=datetime.datetime.now())
        with mock.patch("django.db.migrations.loader.MigrationLoader") as loader:
            # serialize_db_to_string() serializes only migrated apps, so mark
            # the backends app as migrated.
            loader_instance = loader.return_value
            loader_instance.migrated_apps = {"backends"}
            data = connection.creation.serialize_db_to_string()
        self.assertIn('"model": "backends.schoolclass"', data)
        self.assertIn('"year": 1000', data)

    def test_serialize_db_to_string_base_manager_with_prefetch_related(self):
        """
        Tests the serialization of the database to a string using the base database manager with prefetch related objects.
        This test case creates sample school class and school bus instances, linking them together, and then checks that the resulting serialized database string contains the expected models and relationships. The test uses mocking to isolate the migration loader and ensure a consistent test environment. The expected output includes the school bus and school class models, as well as the correct foreign key relationship between them.
        """
        sclass = SchoolClass.objects.create(
            year=2000, last_updated=datetime.datetime.now()
        )
        bus = SchoolBus.objects.create(number=1)
        bus.schoolclasses.add(sclass)
        with mock.patch("django.db.migrations.loader.MigrationLoader") as loader:
            # serialize_db_to_string() serializes only migrated apps, so mark
            # the backends app as migrated.
            loader_instance = loader.return_value
            loader_instance.migrated_apps = {"backends"}
            data = connection.creation.serialize_db_to_string()
        self.assertIn('"model": "backends.schoolbus"', data)
        self.assertIn('"model": "backends.schoolclass"', data)
        self.assertIn(f'"schoolclasses": [{sclass.pk}]', data)


class SkipTestClass:
    def skip_function(self):
        pass


def skip_test_function():
    pass


def expected_failure_test_function():
    pass


class TestMarkTests(SimpleTestCase):
    def test_mark_expected_failures_and_skips(self):
        """
        Parameters
        ----------
        None

        Returns
        -------
        None

        Description
        -----------
        Tests the functionality of marking expected failures and skips in a database creation context.
        This function verifies that the `mark_expected_failures_and_skips` method correctly identifies and marks test functions and classes as expected failures or skips.
        It checks that the `__unittest_expecting_failure__` attribute is set for test functions marked as expected failures, and that the `__unittest_skip__` and `__unittest_skip_why__` attributes are set for test functions and classes marked as skips.
        The test uses a mock database connection and BaseDatabaseCreation instance to simulate the marking process.
        """
        test_connection = get_connection_copy()
        creation = BaseDatabaseCreation(test_connection)
        creation.connection.features.django_test_expected_failures = {
            "backends.base.test_creation.expected_failure_test_function",
        }
        creation.connection.features.django_test_skips = {
            "skip test class": {
                "backends.base.test_creation.SkipTestClass",
            },
            "skip test function": {
                "backends.base.test_creation.skip_test_function",
            },
        }
        creation.mark_expected_failures_and_skips()
        self.assertIs(
            expected_failure_test_function.__unittest_expecting_failure__,
            True,
        )
        self.assertIs(SkipTestClass.__unittest_skip__, True)
        self.assertEqual(
            SkipTestClass.__unittest_skip_why__,
            "skip test class",
        )
        self.assertIs(skip_test_function.__unittest_skip__, True)
        self.assertEqual(
            skip_test_function.__unittest_skip_why__,
            "skip test function",
        )
