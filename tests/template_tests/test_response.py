import pickle
import time
from datetime import datetime

from django.template import engines
from django.template.response import (
    ContentNotRenderedError,
    SimpleTemplateResponse,
    TemplateResponse,
)
from django.test import (
    RequestFactory,
    SimpleTestCase,
    modify_settings,
    override_settings,
)
from django.test.utils import require_jinja2

from .utils import TEMPLATE_DIR


def test_processor(request):
    return {"processors": "yes"}


test_processor_name = "template_tests.test_response.test_processor"


# A test middleware that installs a temporary URLConf
def custom_urlconf_middleware(get_response):
    def middleware(request):
        """
        Middleware function that overrides the URL configuration for an incoming request.

        This function sets the URL configuration to 'template_tests.alternate_urls' and then
        continues the request-response cycle by calling the next middleware or view in the chain.
        It allows for custom URL routing to be applied to a specific request, potentially
        enabling testing or alternate application scenarios.

        :param request: The incoming request object
        :return: The response object generated by the next middleware or view in the chain
        """
        request.urlconf = "template_tests.alternate_urls"
        return get_response(request)

    return middleware


class SimpleTemplateResponseTest(SimpleTestCase):
    def _response(self, template="foo", *args, **kwargs):
        template = engines["django"].from_string(template)
        return SimpleTemplateResponse(template, *args, **kwargs)

    def test_template_resolving(self):
        """

        Tests the template resolving functionality of the SimpleTemplateResponse class.

        This test case verifies that the class correctly resolves and renders templates 
        from a single template string, a list of template strings, and from a response object.
        It checks that the rendered content matches the expected output for each scenario.

        """
        response = SimpleTemplateResponse("first/test.html")
        response.render()
        self.assertEqual(response.content, b"First template\n")

        templates = ["foo.html", "second/test.html", "first/test.html"]
        response = SimpleTemplateResponse(templates)
        response.render()
        self.assertEqual(response.content, b"Second template\n")

        response = self._response()
        response.render()
        self.assertEqual(response.content, b"foo")

    def test_explicit_baking(self):
        # explicit baking
        """

        Tests the explicit rendering of a response.

        This test case verifies that a response is not rendered initially and can be 
        explicitly rendered using the render method. It checks the rendered status of 
        the response before and after rendering to ensure the expected behavior.

        The test consists of the following steps:
            - Create a response object
            - Verify that the response is not rendered initially
            - Render the response explicitly
            - Verify that the response is rendered after calling the render method

        """
        response = self._response()
        self.assertFalse(response.is_rendered)
        response.render()
        self.assertTrue(response.is_rendered)

    def test_render(self):
        # response is not re-rendered without the render call
        response = self._response().render()
        self.assertEqual(response.content, b"foo")

        # rebaking doesn't change the rendered content
        template = engines["django"].from_string("bar{{ baz }}")
        response.template_name = template
        response.render()
        self.assertEqual(response.content, b"foo")

        # but rendered content can be overridden by manually
        # setting content
        response.content = "bar"
        self.assertEqual(response.content, b"bar")

    def test_iteration_unrendered(self):
        # unrendered response raises an exception on iteration
        """
        Tests that attempting to iterate over an unrendered response raises a ContentNotRenderedError.

        This test verifies that the response content must be rendered before it can be iterated over,
        ensuring that rendering is performed before accessing the response data.

        :raises: ContentNotRenderedError if the response is not rendered before iteration.

        """
        response = self._response()
        self.assertFalse(response.is_rendered)

        def iteration():
            list(response)

        msg = "The response content must be rendered before it can be iterated over."
        with self.assertRaisesMessage(ContentNotRenderedError, msg):
            iteration()
        self.assertFalse(response.is_rendered)

    def test_iteration_rendered(self):
        # iteration works for rendered responses
        response = self._response().render()
        self.assertEqual(list(response), [b"foo"])

    def test_content_access_unrendered(self):
        # unrendered response raises an exception when content is accessed
        """

        Tests that accessing the content of an unrendered response raises a ContentNotRenderedError.

        Verifies that the response remains unrendered after attempting to access its content, 
        ensuring that the response's state is consistent and an exception is properly raised 
        when trying to access unrendered content.

        """
        response = self._response()
        self.assertFalse(response.is_rendered)
        with self.assertRaises(ContentNotRenderedError):
            response.content
        self.assertFalse(response.is_rendered)

    def test_content_access_rendered(self):
        # rendered response content can be accessed
        """
        Tests access to the content of a rendered response.

        This method verifies that the content of a rendered response matches the expected output.
        It checks if the rendered content is correctly accessed and if its value is as anticipated.
        The test ensures that the response contains the expected data, in this case, 'foo'.

        """
        response = self._response().render()
        self.assertEqual(response.content, b"foo")

    def test_set_content(self):
        # content can be overridden
        response = self._response()
        self.assertFalse(response.is_rendered)
        response.content = "spam"
        self.assertTrue(response.is_rendered)
        self.assertEqual(response.content, b"spam")
        response.content = "baz"
        self.assertEqual(response.content, b"baz")

    def test_dict_context(self):
        response = self._response("{{ foo }}{{ processors }}", {"foo": "bar"})
        self.assertEqual(response.context_data, {"foo": "bar"})
        response.render()
        self.assertEqual(response.content, b"bar")

    def test_kwargs(self):
        response = self._response(
            content_type="application/json", status=504, charset="ascii"
        )
        self.assertEqual(response.headers["content-type"], "application/json")
        self.assertEqual(response.status_code, 504)
        self.assertEqual(response.charset, "ascii")

    def test_args(self):
        response = SimpleTemplateResponse("", {}, "application/json", 504)
        self.assertEqual(response.headers["content-type"], "application/json")
        self.assertEqual(response.status_code, 504)

    @require_jinja2
    def test_using(self):
        """

        Tests the rendering of a template using different templating engines.

        This function checks that a template is rendered correctly with the default
        templating engine, as well as with the 'django' and 'jinja2' engines specifically.
        It verifies that the rendered content matches the expected output for each case.

        The test covers the usage of the 'using' parameter to specify the templating engine,
        ensuring that the correct engine is used to render the template.

        """
        response = SimpleTemplateResponse("template_tests/using.html").render()
        self.assertEqual(response.content, b"DTL\n")
        response = SimpleTemplateResponse(
            "template_tests/using.html", using="django"
        ).render()
        self.assertEqual(response.content, b"DTL\n")
        response = SimpleTemplateResponse(
            "template_tests/using.html", using="jinja2"
        ).render()
        self.assertEqual(response.content, b"Jinja2\n")

    def test_post_callbacks(self):
        "Rendering a template response triggers the post-render callbacks"
        post = []

        def post1(obj):
            post.append("post1")

        def post2(obj):
            post.append("post2")

        response = SimpleTemplateResponse("first/test.html", {})
        response.add_post_render_callback(post1)
        response.add_post_render_callback(post2)

        # When the content is rendered, all the callbacks are invoked, too.
        response.render()
        self.assertEqual(response.content, b"First template\n")
        self.assertEqual(post, ["post1", "post2"])

    def test_pickling(self):
        # Create a template response. The context is
        # known to be unpicklable (e.g., a function).
        """

        Tests the pickling behavior of a SimpleTemplateResponse object.

        This test checks that a SimpleTemplateResponse object cannot be pickled before it is rendered, 
        raising a ContentNotRenderedError. After rendering, the object can be pickled and unpickled 
        successfully, preserving its content, headers, and status code. Additionally, this test verifies 
        that certain template attributes are not present in the unpickled response, ensuring that the 
        pickling process does not inadvertently expose internal implementation details.

        The test ensures the correctness and safety of pickling SimpleTemplateResponse objects in various 
        scenarios, providing assurance that the serialization and deserialization process works as expected. 

        """
        response = SimpleTemplateResponse(
            "first/test.html",
            {
                "value": 123,
                "fn": datetime.now,
            },
        )
        with self.assertRaises(ContentNotRenderedError):
            pickle.dumps(response)

        # But if we render the response, we can pickle it.
        response.render()
        pickled_response = pickle.dumps(response)
        unpickled_response = pickle.loads(pickled_response)

        self.assertEqual(unpickled_response.content, response.content)
        self.assertEqual(
            unpickled_response.headers["content-type"], response.headers["content-type"]
        )
        self.assertEqual(unpickled_response.status_code, response.status_code)

        # ...and the unpickled response doesn't have the
        # template-related attributes, so it can't be re-rendered
        template_attrs = ("template_name", "context_data", "_post_render_callbacks")
        for attr in template_attrs:
            self.assertFalse(hasattr(unpickled_response, attr))

        # ...and requesting any of those attributes raises an exception
        for attr in template_attrs:
            with self.assertRaises(AttributeError):
                getattr(unpickled_response, attr)

    def test_repickling(self):
        """
        Tests the repickling of a rendered response object after an initial rendering failure.

        This method verifies that a response object cannot be pickled before it is rendered, 
        and checks that the object can be successfully pickled and unpickled after rendering.
        It also tests the subsequent pickling of the unpickled response object, ensuring 
        that the rendering and pickling processes are correctly handled.
        """
        response = SimpleTemplateResponse(
            "first/test.html",
            {
                "value": 123,
                "fn": datetime.now,
            },
        )
        with self.assertRaises(ContentNotRenderedError):
            pickle.dumps(response)

        response.render()
        pickled_response = pickle.dumps(response)
        unpickled_response = pickle.loads(pickled_response)
        pickle.dumps(unpickled_response)

    def test_pickling_cookie(self):
        response = SimpleTemplateResponse(
            "first/test.html",
            {
                "value": 123,
                "fn": datetime.now,
            },
        )

        response.cookies["key"] = "value"

        response.render()
        pickled_response = pickle.dumps(response, pickle.HIGHEST_PROTOCOL)
        unpickled_response = pickle.loads(pickled_response)

        self.assertEqual(unpickled_response.cookies["key"].value, "value")

    def test_headers(self):
        """

        Verifies that user-defined HTTP headers are correctly set in a response object.

        Tests that a custom 'X-Foo' header is successfully added to a SimpleTemplateResponse
        and that its value matches the expected output.

        This test ensures that the application can successfully inject arbitrary HTTP headers
        into its responses, allowing for custom metadata and configuration. 

        """
        response = SimpleTemplateResponse(
            "first/test.html",
            {"value": 123, "fn": datetime.now},
            headers={"X-Foo": "foo"},
        )
        self.assertEqual(response.headers["X-Foo"], "foo")


@override_settings(
    TEMPLATES=[
        {
            "BACKEND": "django.template.backends.django.DjangoTemplates",
            "DIRS": [TEMPLATE_DIR],
            "OPTIONS": {
                "context_processors": [test_processor_name],
            },
        }
    ]
)
class TemplateResponseTest(SimpleTestCase):
    factory = RequestFactory()

    def _response(self, template="foo", *args, **kwargs):
        self._request = self.factory.get("/")
        template = engines["django"].from_string(template)
        return TemplateResponse(self._request, template, *args, **kwargs)

    def test_render(self):
        response = self._response("{{ foo }}{{ processors }}").render()
        self.assertEqual(response.content, b"yes")

    def test_render_with_requestcontext(self):
        response = self._response("{{ foo }}{{ processors }}", {"foo": "bar"}).render()
        self.assertEqual(response.content, b"baryes")

    def test_context_processor_priority(self):
        # context processors should be overridden by passed-in context
        """
        Tests the priority of context processors.

        This test case checks whether the context processor correctly prioritizes
        the rendering of template variables, ensuring that they are replaced with
        the expected values. It verifies that the processors variable is rendered
        with the correct value, taking precedence over other template variables.

        The test is designed to validate the functionality of the template engine's
        context processing mechanism, which is responsible for replacing template
        variables with actual values. It provides a basic assurance that the
        templating system behaves as expected, rendering variables in the correct
        order and with the correct values.

        The expected output is a rendered template where {{ foo }} is effectively
        ignored and {{ processors }} is replaced with 'no', indicating that the
        context processor has correctly prioritized the rendering of the variables
        and replaced them with the expected values.


        """
        response = self._response(
            "{{ foo }}{{ processors }}", {"processors": "no"}
        ).render()
        self.assertEqual(response.content, b"no")

    def test_kwargs(self):
        """

        Tests that a response with keyword arguments is correctly created.

        This test verifies that a response object with a specified content type and status code
        can be successfully generated. It checks that the content type and status code of the
        response match the expected values.

        :param none:
        :return: none
        :raises: AssertionError if the response's content type or status code do not match the expected values.

        """
        response = self._response(content_type="application/json", status=504)
        self.assertEqual(response.headers["content-type"], "application/json")
        self.assertEqual(response.status_code, 504)

    def test_args(self):
        """

        Tests the response arguments of a TemplateResponse object.

        This test case verifies that the 'content-type' header and the status code
        are correctly set in the response object. It checks that the 'content-type' 
        is set to 'application/json' and the status code is set to 504, indicating 
        a Gateway Timeout error.

        """
        response = TemplateResponse(
            self.factory.get("/"), "", {}, "application/json", 504
        )
        self.assertEqual(response.headers["content-type"], "application/json")
        self.assertEqual(response.status_code, 504)

    @require_jinja2
    def test_using(self):
        """

        Tests the rendering of templates using different template engines.

        This test function verifies that templates are rendered correctly when
        different template engines are specified. It checks the response content
        of a test template rendered with the default template engine, as well as
        with the 'django' and 'jinja2' template engines.

        The test template used for this function contains template code that
        should render differently depending on the template engine used.

        """
        request = self.factory.get("/")
        response = TemplateResponse(request, "template_tests/using.html").render()
        self.assertEqual(response.content, b"DTL\n")
        response = TemplateResponse(
            request, "template_tests/using.html", using="django"
        ).render()
        self.assertEqual(response.content, b"DTL\n")
        response = TemplateResponse(
            request, "template_tests/using.html", using="jinja2"
        ).render()
        self.assertEqual(response.content, b"Jinja2\n")

    def test_pickling(self):
        # Create a template response. The context is
        # known to be unpicklable (e.g., a function).
        response = TemplateResponse(
            self.factory.get("/"),
            "first/test.html",
            {
                "value": 123,
                "fn": datetime.now,
            },
        )
        with self.assertRaises(ContentNotRenderedError):
            pickle.dumps(response)

        # But if we render the response, we can pickle it.
        response.render()
        pickled_response = pickle.dumps(response)
        unpickled_response = pickle.loads(pickled_response)

        self.assertEqual(unpickled_response.content, response.content)
        self.assertEqual(
            unpickled_response.headers["content-type"], response.headers["content-type"]
        )
        self.assertEqual(unpickled_response.status_code, response.status_code)

        # ...and the unpickled response doesn't have the
        # template-related attributes, so it can't be re-rendered
        template_attrs = (
            "template_name",
            "context_data",
            "_post_render_callbacks",
            "_request",
        )
        for attr in template_attrs:
            self.assertFalse(hasattr(unpickled_response, attr))

        # ...and requesting any of those attributes raises an exception
        for attr in template_attrs:
            with self.assertRaises(AttributeError):
                getattr(unpickled_response, attr)

    def test_repickling(self):
        response = SimpleTemplateResponse(
            "first/test.html",
            {
                "value": 123,
                "fn": datetime.now,
            },
        )
        with self.assertRaises(ContentNotRenderedError):
            pickle.dumps(response)

        response.render()
        pickled_response = pickle.dumps(response)
        unpickled_response = pickle.loads(pickled_response)
        pickle.dumps(unpickled_response)

    def test_headers(self):
        """
        Tests that custom HTTP headers are correctly set in a TemplateResponse. 

        Verifies that the 'X-Foo' header is properly included in the response with the expected value 'foo'. This test ensures that the headers dictionary passed to the TemplateResponse is properly utilized.
        """
        response = TemplateResponse(
            self.factory.get("/"),
            "first/test.html",
            {"value": 123, "fn": datetime.now},
            headers={"X-Foo": "foo"},
        )
        self.assertEqual(response.headers["X-Foo"], "foo")


@modify_settings(
    MIDDLEWARE={"append": ["template_tests.test_response.custom_urlconf_middleware"]}
)
@override_settings(ROOT_URLCONF="template_tests.urls")
class CustomURLConfTest(SimpleTestCase):
    def test_custom_urlconf(self):
        """

        Tests that the custom URL configuration is correctly routing the template response view.

        Verifies that a GET request to the '/template_response_view/' URL returns a successful response containing the expected content.

        """
        response = self.client.get("/template_response_view/")
        self.assertContains(response, "This is where you can find the snark: /snark/")


@modify_settings(
    MIDDLEWARE={
        "append": [
            "django.middleware.cache.FetchFromCacheMiddleware",
            "django.middleware.cache.UpdateCacheMiddleware",
        ],
    },
)
@override_settings(
    CACHE_MIDDLEWARE_SECONDS=2, ROOT_URLCONF="template_tests.alternate_urls"
)
class CacheMiddlewareTest(SimpleTestCase):
    def test_middleware_caching(self):
        response = self.client.get("/template_response_view/")
        self.assertEqual(response.status_code, 200)

        time.sleep(1.0)

        response2 = self.client.get("/template_response_view/")
        self.assertEqual(response2.status_code, 200)

        self.assertEqual(response.content, response2.content)

        time.sleep(2.0)

        # Let the cache expire and test again
        response2 = self.client.get("/template_response_view/")
        self.assertEqual(response2.status_code, 200)

        self.assertNotEqual(response.content, response2.content)
